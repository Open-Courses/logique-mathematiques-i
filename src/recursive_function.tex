\chapter{Fonctions récursives}

% Références :
%	- Boffa

%\section{Historique}

%Les mathématiques ont comme base le calcul. % Provenance du mot calcul
%Au fil des années, les méthodes de calculs ont évoluées, et les mathématiques ont
%évoluées en diverses branches, comme l'algèbre, l'analyse, les probabilités, les
%statistiques. Le calcul est alors devenue une branche des mathématiques, appelée
%l'arithmétique.

%Au fur et à mesure des années, on a cherché des méthodes automatiques de calcul.
%On a cherché à éviter de répéter, encore et encore, les mêmes calculs. On a
%aussi également cherché à simplifier certains calculs. %Exemple des tables de log.

%Bien que la notion de \textbf{calcul} nous semble évidente, nous avons besoin de
%définir cette notion.


%\section{Premières définitions}

%Posons directement la définition de \textbf{fonctions récursives}:

%\begin{definition}
	%Une \textbf{fonction récursive} est une fonction calculable par un
	%algorithme. C'est-à-dire qu'il existe un algorithme qui pour tout $a$ dans
	%l'ensemble de départ de la fonction, calcule son image.
%\end{definition}

%Cette définition nous définit la classe des fonctions dont on est capable de
%calculer grace à une méthode de calcul.

%Il reste cependant à définir quel méthode de calcul nous utilisons, et bien sûr,
%de définir de manière rigoureuse ce qu'est un algorithme.

%D'abord, il nous faut poser ce qu'on entend par \textbf{calcul}. ?????

%méthode de calcul ?????

%Il existe plusieurs méthodes de calcul:

%\begin{enumerate}
	%\item Machine de Turing
	%\item $\lambda$-calcul
	%\item Système de Post
	%\item Algorithmes de Markov
%\end{enumerate}

\section{Notions de base}

Bien que nous n'ayons pas défini la notion \textit{d'algorithme}, nos
expériences en informatique nous donne une intuition. Un algorithme est une
suite finie d'instruction qui pour une certaine entrée, nous donne une sortie.

Nous supposerons par la suite que nous disposons d'une définition précise, et
définie mathématiquement, et dont notre intuition vérifie la définition.
Nous pourrons alors utiliser notre expérience pour donner des résultats.

\begin{definition}
	Soit $X$ un ensemble.

	On dit que $X$ est \textbf{un espace} s'il vérifie les conditions suivantes:

	\begin{enumerate}
		\item $X$ est infini
		\item $X \subset A^{*}$ où $A$ est un ensemble fini et $A^{*}$ est
			l'ensemble des suites finies qui ont comme composantes des éléments
			de $A$.
		\item Soit $x \in A^{*}$, alors il existe un algorithme booléen $A_{x}$ tel que
			$x \in X \equiv A_{x}(x)$ vrai.
	\end{enumerate}
\end{definition}

Nous allons alors supposer que certains ensembles soient des \textit{espaces}.
Les voici:

\begin{enumerate}
	\item $\naturel$ est un espace.
	\item Soient deux ensembles $X$ et $Y$ qui sont des espaces resp. sur $A^{*}
		$ et $B^{*}$, alors $X \cartprod Y$ est un espace sur $A^{*} \union
		B^{*} \union \GSset{\xi}$ où $\xi$ est un symbole n'appartenant à
		aucun des alphabets $A$ et $B$.
	\item Soit $X$ un ensemble qui est un espace, alors l'ensemble des mots
		finis sur $X$ ie $X^{*}$, est un espace.
\end{enumerate}

Comme nous faisons pour n'importe quelle structure sur un ensemble, nous allons
définir les morphismes entre ces espaces. Cependant, pour garder une intuition
informatique, nous allons appelé ces morphismes des \textbf{fonctions
récursives}. Les fonctions récursives doivent transporter la structure des
éléments, ce qui motive la définition suivante.

\begin{definition}
	Soient $X$ et $Y$ deux espaces.
	Une fonction $\GSfunction{f}{X}{Y}$ est dite \textbf{récursive} s'il existe
	un algorithme $A$ tel que pour tout $x \in X$, $A$ calcule $F(x)$.
\end{definition}

Rappelons que nous n'avons pas défini précisément la notion d'algorithme.
Cependant, nous avons supposé que nous en avons défini une, et que cette
définition recouvre toutes les opérations que nous pouvons réaliser dans un
langage de programmation.

Donnons quelques exemples de \textit{fonctions récursives}.

\begin{exemple}
	\begin{enumerate}
		\item Prenons $A = \naturel \cartprod \naturel$, et $B = \naturel$.
			Alors l'addition usuelle ($\GSfunction{+}{\naturel \cartprod
			\naturel}{\naturel}$) et la multiplication usuelle
			($\GSfunction{.}{\naturel \cartprod \naturel}{\naturel}$) sont des
			fonctions récursives.
		\item Soit $X$ un espace, alors l'identité $\GSfunction{Id_{X}}{X}{X}$
			est une fonction récursive.
		\item Soient $X$ et $Y$ deux espaces. Alors les fonctions de projections
			sur $X$ et sur $Y$ sont des fonctions récursives.
		\item Soit $X$ un espace, et prenons $X^{*}$ l'ensemble des mots finis
			sur $X$.
			Soit $\GSfunction{l}{X^{*}}{\naturel}$ la fonction qui calcule la
			longueur du mot. Alors $l$ est une fonction récursive.
	\end{enumerate}
\end{exemple}

Prenons maintenant deux fonctions récursives $f$ et $g$. Si nous faisons le
parallèle avec les structures de groupe ou d'espaces vectoriels, nous savons que
la composition que la composition de deux morphismes est encore un morphisme.
Nous obtenons alors le même résultat pour les fonctions récursives.

\begin{proposition}
	Soient $X$, $Y$ et $Z$ trois espaces.
	Soient $\GSfunction{f}{X}{Y}$ et $\GSfunction{g}{Y}{Z}$ deux fonctions
	récursives.

	Alors $\GSfunction{g \circ f}{X}{Z}$ est aussi une fonction récursive.
\end{proposition}

\ifdefined\outproof
\begin{proof}

\end{proof}
\fi

Nous pouvons alors de la même manière que dans les structures connues, définir
les \textit{isomorphismes} entre les espaces.
Rappelons que si $f$ est un morphisme bijectif, il n'est pas toujours vrai que
$f^{-1}$ soit aussi un morphisme: cela dépend des structures. En effet, pour les
structure de groupe, $f^{-1}$ est également un morphisme. Or, pour les
applications continues (qui sont les morphismes des structures topologiques),
ce n'est pas toujours vrai.

Rappelons que la notion de bijectivité ne demande aucune structure, celle-ci
n'est qu'ensembliste.

\begin{definition}
	Soient $X$ et $Y$ deux espaces.
	Soit $\GSfunction{f}{X}{Y}$ une fonction récursive bijective tel que
	$\GSfunction{f^{-1}}{Y}{X}$ est aussi récursive.
	Alors on dit que $f$ est \textbf{un isomorphisme}.
\end{definition}

Nous arrivons alors à un théorème très surprenant concernant les espaces.

Revenons aux structures algébriques que nous connaissons, comme celle de groupe.
Nous savons que pour deux groupes donnés, il n'existe pas nécessairement
d'isomorphismes entre les deux. Donc, tous les groupes ne sont pas isomorphes.
Par exemple, $\integer/2\integer$ et $\integer/4\integer$ ne sont pas
isomorphes.

\begin{theorem}
	\label{theorem:isomorphism_theorem}
	Tous les espaces sont isomorphes.
\end{theorem}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

\begin{definition}
	Soit $X$ un espace. Soit $E \subseteq X$.

	On dit que \textbf{récursif} si la fonction caractéristique de $E$ sur $X$
	est récursive, c'est-à-dire s'il existe un algorithme qui, pour tout élément
	$x$ de $X$, détermine $x \in E$ ou non.
\end{definition}


\section{Indices}

Nous avons vu que $\naturel^{*}$, l'ensemble des mots finis sur le langage
$\naturel$, c'est-à-dire les suites naturelles finies, est un espace car
$\naturel$ est un espace.

Un élément de $Alg(\naturel^{*}, \naturel)$ est un algorithme dont les entrées
sont des mots finis (de taille variable sur tous les naturels $k \in \naturel$)
et dont les sorties sont des naturels.

Nous savons aussi que $Alg(\naturel^{*}, \naturel)$ est isomorphe en tant qu'espace
à $\naturel$ car tous les espaces sont isomorphes.

Fixons alors un isomorphisme de $\naturel$ dans $Alg(\naturel^{*},
\naturel)$ tel que $n$ est associé à $I_{n} \in Alg(\naturel^{*}, \naturel)$.

Nous avons défini la notation $[I_{n}]$, pour un algorithme $I_{n}$, qui
représente la fonction récursive partielle que calcule $I_{n}$.

Par l'isomorphisme, on note $[n]$ à la place de $[I_{n}]$.

Nous pouvons en particulier regarder comment les mots de taille $k$, pour $k$
fixé, sont calculés par l'algorithme $I_{n}$.

\begin{notation}
	$[n]^{k}$ est la restriction de $[I_{n}]$ à $\naturel^{k}$.
\end{notation}


\section{Fonctions récursives primitives}

Pour certaines structures, comme les espaces vectoriels ou les groupes, nous
pouvons, sous certaines conditions, trouver des éléments qui génèrent tout
l'espace vectoriel (les bases) ou tout le groupe (générateurs).

Pour les espaces vectoriels de dimension finie, nous savons qu'il existe une
suite finie d'élément de l'espace tel que chaque élément est définissable par
ces éléments et grace au \textit{principe des combinaisons linéaires}.

En est-il de même pour l'ensemble des fonctions récursives
$\recursiveFunctionsSet$ ? Pouvons-nous trouver des fonctions récursives 'de
base' et un ou plusieurs principes permmettant de \textit{générer} toutes les
autres fonctions récursives ?

Dans ce but, nous allons définir les fonctions \textbf{récursives primitives
(RP)} ainsi que le principe de composition et le principe de récurrence.
L'ensemble des fonctions constructibles grace à ces axiomes sera noté
$\primitiveRecursiveFunctionSet$.

Rappelons que comme tous les espaces sont isomorphes, nous pouvons sans perte de
généralité travailler avec $\naturel^{k}$, $k$ étant un naturel strictement
positif. Nous étudierons alors les fonctions
$\GSfunction{f}{\naturel^{k}}{\naturel}$.

\vspace{5mm}

La question qu'on se posera sera alors: \textbf{est-ce que
$\primitiveRecursiveFunctionSet = \recursiveFunctionsSet$ ?}

\vspace{5mm}

Commençons par définir 'les vecteurs de bases'.

\begin{enumerate}
	\item \textbf{La fonction annulatrice} ou \textbf{nulle}
		\begin{equation}
			NULL : \naturel \rightarrow \naturel : x \rightarrow 0
		\end{equation}
		est RP.
	\item \textbf{La fonction successeur}
		\begin{equation}
			SUCC : \naturel \rightarrow \naturel : x \rightarrow x + 1
		\end{equation}
		est RP
	\item Soit $k \in \naturel^{> 0}$ et soit $1 \leq l \leq k$. \textbf{La
		fonction de $k$-projection sur la $l$-ième composante}
		\begin{equation}
			P_{k, l} : \naturel^{k} \rightarrow \naturel : (x_{1}, \cdots, x_{k}) \rightarrow x_{l}
		\end{equation}
		est RP.
\end{enumerate}

\vspace{5mm}

Nous allons aussi donner deux procédés permettant, à partir de deux fonctions
RP, de construires d'autres fonctions RP.

\begin{definition} [Principe de composition]
	Soit $\GSfunction{F}{\naturel^{l}}{\naturel}$ et soient
	$\GSfunction{F_{i}}{\naturel^{k}}{\naturel}$ ($1 \leq i \leq l$) des
	fonctions RP.

	Alors la fonction $H : \naturel^{k} \rightarrow \naturel$ tel que
	\begin{align}
		(x_{1}, \cdots, x_{k}) \rightarrow F(F_{1}(x_{1}, \cdots, x_{k}), \cdots, F_{l}(x_{1}, \cdots, x_{k}))
	\end{align}
	est RP.
\end{definition}

\begin{definition} [Principe de récurrence]
	Soient $\GSfunction{F}{\naturel^{k}}{\naturel}$ et
	$\GSfunction{G}{\naturel^{k + 2}}{\naturel}$ deux fonctions RP.
	Alors la fonction $\GSfunction{H}{\naturel^{k + 1}}{\naturel}$ définie comme:

	\begin{enumerate}
		\item $H(x_{1}, \cdots, x_{k}, 0) = F(x_{1}, \cdots, x_{k})$
		\item $H(x_{1}, \cdots, x_{k}, x + 1) = G(x_{1}, \cdots, x_{k}, x,
			H(x_{1}, \cdots, x_{k}, x))$
	\end{enumerate}
	est RP.
\end{definition}

Nous pouvons montrer que, dans le principe de composition et de récurrence, il
n'est pas nécessaire que les fonctions aient le même domaine (ie dépendent du
même nombre de paramètres). Cela découle du principe de composition et de
l'hypothèse que les fonctions projections soient RP.

Remarquons un point essentiel: les fonctions RP actuellement définies sont
toutes totales. En effet, les principes de construction conservent la propriété
d'être totale, et les fonctions RP de base sont totales.

Nous pouvons alors déduire directement que $\primitiveRecursiveFunctionSet \neq
\recursiveFunctionsSet$ car nous savons qu'il existe des fonctions récursives
qui ne sont pas totales.

Cependant, il existe tout de même un lien entre $\primitiveRecursiveFunctionSet$
et $\recursiveFunctionsSet$. En effet, toutes fonctions récursives primitives
est récursive.

\begin{proposition}
	$\primitiveRecursiveFunctionSet \subsetneq \recursiveFunctionsSet$.
\end{proposition}

\ifdefined\outputproof
\begin{proof}
	Les fonctions de bases sont récursives. De plus, nous avons vu que la
	composition de fonctions récursives est encore récursive. Il nous reste à
	montrer que le principe de récursion conservent la structure de fonctions
	récursives. Nous pouvons l'accepter sans aucun doute vu notre utilisation
	des algorithmes récursifs en programmation.
\end{proof}
\fi

Donnons maintenant quelques exemples de fonctions récursives primitives. Ces
fonctions devront être totales récursives en particulier.

\begin{exemple} [Addition]
	La fonction d'addition
	\begin{equation}
		ADD : \naturel^{2} \rightarrow \naturel : (x, y) \rightarrow x + y
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	Posons
	\begin{equation}
		G : \naturel^{3} \rightarrow \naturel : (x, y, z) \rightarrow SUCC(P_{3,
		3}(x, y, z))
	\end{equation}
	et $F = P_{1, 1}$.

	On a alors
	\begin{equation}
		ADD(x, 0) = F(x) = P_{1, 1}(x) = x
	\end{equation}
	et
	\begin{align}
		ADD(x, y + 1) &= G(x, y, ADD(x, y)) \\
		&= SUCC(ADD(x, y)) \\
		&= (x + y) + 1 \\
		&= x + (y + 1)
	\end{align}
\end{proof}
\fi

Nous pouvons aussi généraliser l'addition à $n$ termes.

\begin{exemple} [Addition de $n$ termes]
	La fonction d'addition de $n$ termes
	\begin{equation}
		ADD_{n} : \naturel^{n} \rightarrow \naturel : (x_{1}, \cdots, x_{n})
		\rightarrow \sum_{i = 1}^{n} x_{i}
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	Il suffit d'appliquer le principe de récurrence sur $ADD$ en remarquant que
	\begin{equation}
		ADD_{n}(x_{1}, \cdots, x_{n}) = ADD(x_{1}, ADD(x_{2}, ADD(\cdots,
		x_{n})))
	\end{equation}
\end{proof}
\fi

\begin{exemple} [Multiplication]
	La fonction de multiplication
	\begin{equation}
		MULT : \naturel^{2} \rightarrow \naturel : (x, y) \rightarrow x . y
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	Posons
	\begin{equation}
		G : \naturel^{3} \rightarrow \naturel : (x, y, z) \rightarrow
		ADD(NULL(x), ADD(y, z))
	\end{equation}
	et $F = NULL$.

	$G$ est bien RP car c'est une composition de fonctions RP.

	On obtient
	\begin{equation}
		MULT(x, 0) = NULL(x) = 0
	\end{equation}
	et
	\begin{align}
		MULT(x, y + 1) & = G(x, y, MULT(x, y)) \\
		& = ADD(NULL(x), ADD(y, MULT(x, y))) \\
		& = NULL(x) + ADD(y, MULT(x, y)) \\
		& = 0 + y + x . y = x . (y + 1)
	\end{align}
\end{proof}
\fi

\begin{exemple} [Projection de l'image d'une fonction]
	Soit $F : \naturel \rightarrow \naturel$ une fonction RP. Alors
	\begin{equation}
		G : \naturel^{2} \rightarrow \naturel : (x, y) \rightarrow G(x,
		y) = F(x)
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	On a $G(x, y) = F(P_{2, 1}(x, y))$. Par le principe de composition, $G$ est
	RP.
\end{proof}
\fi

\begin{exemple} [Fonction symétrie]
	Soit $F : \naturel^{2} \rightarrow \naturel$ une fonction RP. Alors
	\begin{equation}
		G : \naturel^{2} \rightarrow \naturel : (x, y) \rightarrow G(x,
		y) = F(y, x)
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	On a $G(x, y) = F(P_{2, 2}(x, y), P_{2, 1}(x, y))$. Donc $G$ est RP car
	composition de fonctions RP.
\end{proof}
\fi

\begin{exemple} [Diagonale]
	Soit $F : \naturel^{2} \rightarrow \naturel$ une fonction RP. Alors
	\begin{equation}
		G : \naturel \rightarrow \naturel : x \rightarrow G(x) = F(x, x)
	\end{equation}
	est RP.
\end{exemple}

\ifdefined\outputproof
\begin{proof}
	On a $G(x) = F(x, x) = F(P_{2, 1}(x, y), P_{2, 1}(x, y))$. Par le principe
	de composition, $G$ est RP.
\end{proof}
\fi

\begin{exemple}
	\begin{enumerate}
		\item La fonction soustraction est RP (si on définit $0 - 1 = 0$)
		\item La plupart des fonctions que nous utilisons en arithmétique sont
			RP.
		\item Les boucles, les conditions et les comparaisons peuvent être
			implémentées grace aux fonctions RP. (voir Cutland)
	\end{enumerate}
\end{exemple}

Généralisons la notion de fonctions RP aux fonctions de $\naturel^{k}$ dans
$\naturel$.

\begin{definition} [Récursive primitive dans $\naturel^{2}$]
	Soit $k \in \naturel^{> 1}$.
	\begin{equation}
		F : \naturel \rightarrow \naturel^{k} : x \rightarrow (F_{1}(x), \cdots,
		F_{k}(x))
	\end{equation}
	une fonction.

	On dit que $F$ est \textbf{récursive primitive} si pour tout $1 \leq i \leq
	k$, $F_{i}$ sont récursives primitives.

	Si de plus $F$ est bijectif, on dit que $F$ est \textbf{un RP-isomorphisme}.
\end{definition}

\begin{definition} [RP isomorphe]
	Soient $k \in \naturel$. On dit que $\naturel^{k}$ est \textbf{RP-isomorphe à
	$\naturel$} s'il existe un RP-isomorphisme de $\naturel^{k}$ dans $\naturel$.
\end{definition}

\begin{proposition}
	$\naturel^{2}$ est RP-isomorphe à $\naturel$.
\end{proposition}

\ifdefined\outputproof
\begin{proof}
	% TODO
\end{proof}
\fi

Nous souhaitons atteindre notre but qui est de définir des principes de bases et des
fonctions de base permettant de décrire \textbf{toutes} les fonctions
récursives.

Vu que la construction actuelle des fonctions RP ne permet pas de construire
toutes les fonctions récursives car nous ne pouvons définir les fonctions
récursives partielles, nous souhaiterions rajouter un principe qui construit, en
particulier, les fonctions partielles.

Nous montrerons qu'en fait, toutes les fonctions totales récursives ne sont pas
RP, c'est-à-dire que si nous notons $\recursiveFunctionsSet_{T}$ l'ensemble des
fonctions récursives totales, on a $\primitiveRecursiveFunctionSet \subsetneq
\recursiveFunctionsSet_{T}$. On construira la fonction
d'Ackermann qui montrera cette proposition.

Nous allons introduire de la principe de minimalisation.

\begin{definition} [Principe de minimalisation ou principe $\mu$]
	Soit $\GSfunction{F}{\naturel^{k + 1}}{\naturel}$ une fonction RP.

	Alors on définit
	$G : \naturel^{k} \rightarrow \naturel$ tel que

	$G(x_{1}, \cdots, x_{k})$ = le plus petit $y \in \naturel$ tel que $F(x_{1}, \cdots, x_{k}, y) = 0$

On note $G(x_{1}, \cdots, x_{k}) = [\mu y](F(x_{1}, \cdots, x_{k}, y) = 0)$.

	$G$ est appelée \textbf{la fonction de minimalisation de $F$.}

	Les fonctions récursives constructibles à partir de
	$\primitiveRecursiveFunctionSet$ et du principe de minimalisation sont
	appelées \textbf{fonctions $\mu$-récursives}, et la classe des fonctions
	$\mu$-recursives est noté $\muRecursiveFunctionSet$.
\end{definition}

\begin{remarque}
	La fonction de minimalisation d'une fonction $RP$ n'est pas nécessairement
	totale. En effet, on pourrait avoir que $F(x_{1}, \cdots, x_{k}, y)$ ne
	s'annule jamais. La fonction $\mu$ sera alors indéterminée pour cette entrée
	là. Un exemple est la fonction successeur (transformée en une fonction à
	deux paramètres grace à la projection).  La fonction $\mu$ est donc
	partielle !
\end{remarque}

\begin{question} Est-ce que si on se restreint aux fonctions $\mu$-récursives,
	alors la classe $\muRecursiveFunctionSet$ est exactement la classe des
	fonction primitives récursives $\primitiveRecursiveFunctionSet$ ?

	En d'autres termes, est-ce que le principe de minimalisation ne permet que
	de construire des nouvelles fonctions récursives partielles ?
\end{question}

Nous venons donc de trouver un principe nous permettant d'agrandir notre classe
de fontions RP et qui permet de définir des fonctions partielles. Mais est-ce
necessaire pour pouvoir construire toutes les fonctions récursives ?

Pour le savoir, nous allons passer par un théorème important.

Nous allons introduire une notation permettant de comparer les fonctions
récursives.

\begin{definition} [Egalité entre fonctions récursives]
	Soient $F$ et $G$ deux fonctions récursives de $\naturel^{k}$
	dans $\naturel$.

	On note $F \simeq G$ si $F$ et $G$ ont même domaine et
	sont égales sur celui-ci, et $F$ est indéterminée en $x$ ssi $G$ l'est
	aussi. Nous étendons également la notation pour l'évalutation.
\end{definition}

Bien qu'on ait besoin d'introduire un nouveau principe pour construire des
fonctions partielles, les fonctions primitives récursives constructibles sans le
principe de minimalisation jouent un role important.

\begin{theorem} [Forme normale de Kleene]
	\label{theorem:kleene_normal_form}
	Soit $k \in \naturel^{> 0}$.
	Il existe $\GSfunction{T}{\naturel^{k + 2}}{\naturel}$ et
	$\GSfunction{U}{\naturel}{\naturel}$ deux fonctions primitives récursives
	(ie $T, U \in \primitiveRecursiveFunctionSet$) tel que pour toute fonction
	$\GSfunction{F}{\naturel^{k}}{\naturel}$ $\mu$ récursive (ie $F \in
	\muRecursiveFunctionSet$), il existe un entier $e \in \naturel$ tel que pour
	tout $(x_{1}, \cdots, x_{k}) \in \naturel^{k}$

	\begin{equation*}
		F(x_{1}, \cdots, x_{k}) \simeq U(\mu y (T(y, e, x_{1}, \cdots, x_{k})))
	\end{equation*}

	$e$ est appelé \textbf{index} ou \textbf{nombre de Godel}.
\end{theorem}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

Le théorème de la forme normale de Kleene nous dit que toute fonction
$\mu$-récursives peut-être construite à partir d'une seule application du
principe de minimalisation et uniquement de deux fonctions primitives
récursives. On est alors amené au corollaire suivant:

\begin{corollary}
	Chaque fonction partielle récursive est constructible à partir des fonctions de bases
	et aux principes de composition, de récurrrence et de minimalisation.
\end{corollary}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

\begin{theorem}
	Nous avons $\muRecursiveFunctionSet = \recursiveFunctionsSet$.
\end{theorem}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

\section{Opérateurs}

%Nous savons que le nombre de programmes est dénombrables: on peut alors les
%numéroter. Posons $\phi$ la fonction qui a $n \in \naturel$ associé $\phi(n) =
%\phi_{n}$ le $n$-ième programme.

%Nous allons définir ce qu'est un point fixe pour $\phi$.

%\begin{definition}
	%Soit $F$ une fonction. On dit que $e \in \naturel$ est un point fixe de $F$
	%si $\phi_{e} \simeq \phi_{F(e)}$, c'est-à-dire que $e$ et $F(e)$ décrivent
	%le même programme.
%\end{definition}

\begin{definition} [Fonction finie]
	Une fonction est dite \textbf{finie} si son domaine est fini.
\end{definition}

\begin{notation}
	On note $\mathcal{F}_{k}$ ($k \in \naturel^{> 0}$) les fonctions
	\textbf{partielles} de $\naturel^{k}$ dans $\naturel$.
\end{notation}

\begin{definition} [Opérateur]
	Soient $k, l \in \naturel^{> 0}$.
	\textbf{Un opérateur} est une fonction
	\begin{equation}
		\GSfunction{\phi}{\mathcal{F}_{k}}{\mathcal{F}_{l}}
	\end{equation}
totale (c'est-à-dire que son domaine de définition est tout
	$\mathcal{F}_{k}$).

	On dit que $\phi$ est \textbf{un opérateur continu} si

	\begin{equation*}
		\forall F \in \mathcal{F}_{k}, \phi(F) = \displaystyle \bigcup_{\substack{f \subseteq
			F \\ f \text{ finie}}} \phi(f)
	\end{equation*}
\end{definition}

\begin{remarque}
	La notion de continuité d'opérateur se fait sur des fonctions. Il faut
	montrer une égalité de fonctions.
\end{remarque}

La définition nous permet directement de montrer les propositions suivantes:

\begin{proposition}
	Soit $\GSfunction{\phi}{\mathcal{F}_{k}}{\mathcal{F}_{k}}$ un opérateur
	continu.

	Alors:

	\begin{enumerate}
		\item $\forall F_{1} \subseteq F_{2} \in {\mathcal{F}_{k}}$,
			$\phi(F_{1}) \subseteq \phi(F_{2})$
		\item $\forall \GSsequence{F}{i}{I}$, $\displaystyle \phi(\bigcup_{i \in I} F_{i}) =
			\bigcup_{i \in I} \phi(F_{i})$.
	\end{enumerate}
\end{proposition}

\ifdefined\outputproof
\begin{proof}
	Evident.
\end{proof}
\fi

\begin{definition} [Point fixe]
	Soit $\gamma : \mathcal{F}_{k} \rightarrow \mathcal{F}_{k}$ un opérateur et
	soit $F \in \mathcal{F}_{k}$.

	On dit que $F$ est \textbf{un point fixe de $\gamma$} si $\gamma(F) = F$.
\end{definition}

\begin{theorem} [Théorème du plus petit point fixe]
	\label{theorem:plus_petit_point_fixe}
	Soit $\gamma$ est un opérateur continu de $\mathcal{F}_{k}$ dans
	$\mathcal{F}_{k}$.

	Alors $Fix(\gamma) = \displaystyle \bigcup_{i \in \naturel} \gamma^{i}(\emptyset)$ est le
	plus petit point fixe de $\gamma$.
\end{theorem}

\ifdefined\outputproof
\begin{proof}
	\begin{enumerate}
		\item Montrons que $Fix(\gamma)$ est un point fixe. Il faut montrer que
			\begin{equation}
				\gamma(\bigcup_{i \in \naturel} \gamma^{i}(\emptyset)) = \bigcup_{i \in
				\naturel} \gamma^{i}(\emptyset)
			\end{equation}

			Comme $\gamma$ est continu, on a
			\begin{equation}
				\gamma(\bigcup_{i \in \naturel} \gamma^{i}(\emptyset)) = \bigcup_{i \in
				\naturel} \gamma(\gamma^{i}(\emptyset)) = \bigcup_{i \in
				\naturel} \gamma^{i + 1}(\emptyset)
			\end{equation}
			Comme
			\begin{equation}
				\bigcup_{i \in \naturel} \gamma^{i}(\emptyset) = \gamma^{0}(\emptyset)
				\union \bigcup_{i \in \naturel^{> 0}} \gamma^{i}(\emptyset) = \bigcup_{i
					\in \naturel^{> 0}} \gamma^{i}(\emptyset)
			\end{equation}
			on a bien ce qu'on veut.

		\item Maintenant, si $P \in \mathcal{F}_{k}$ est un autre point fixe de $\gamma$ (ie $\gamma(P) =
			P$), nous devons montrer que $Fix(\gamma) \subseteq P$.

			On a, comme $\gamma$ est continu et que $\emptyset \subseteq P$,
			$\gamma(\emptyset) \subseteq \gamma(P) = P$.

			Par récurrence, on montre que, pour tout $i \in \naturel$,
			$\gamma^{i}(\emptyset) \subseteq P$.

			En particulier, on a donc
			\begin{equation}
				Fix(\gamma) := \bigcup_{i \in \naturel} \gamma^{i}(\emptyset) \subseteq
				P
			\end{equation}
	\end{enumerate}
	\end{proof}
\fi

Avant de donner un exemple, montrons une proposition qui nous servira pour le
futur exemple.

En analyse fonctionnelle, nous savons que toute fonction constante est
continue. Est-ce le cas pour notre définition sur les opérateurs ?

\begin{proposition}
	Soient $k, l > 0$ deux naturels.
	Soit $\GSfunction{\phi}{\mathcal{F}_{k}}{\mathcal{F}_{l}}$ un opérateur
	constant, c'est-à-dire que pour tout $F \in \mathcal{F}_{k}$, $\phi(F) = A$
	où $A \in \mathcal{F}_{l}$.

	Alors $\phi$ est continue. De plus, $Fix(\phi) = A$.
\end{proposition}

\ifdefined\outputproof
\begin{proof}
	Il faut montrer
	\begin{equation}
		\forall F \in \mathcal{F}_{k}, \phi(F) = \displaystyle \bigcup_{\substack{f \subseteq
			F \\ f \, \text{ finie}}} \phi(f)
	\end{equation}
	Soit $F \in \mathcal{F}_{k}$.
	On a $\phi(F) = A$ car $\phi$ constante et
	\begin{equation}
		\bigcup_{\substack{f \subseteq F \\ f \, finie}} \phi(f) =
		\bigcup_{\substack{f \subseteq F \\ f \, finie}} A = A
	\end{equation}
	Donc $\phi$ est continu.

	De plus, on a $\bigcup_{i \in \naturel} \gamma^{i}(\emptyset) = A$ car
	$\phi$ constante.
\end{proof}
\fi


%Donnons maintenant un exemple d'opérateur continu, et calculons son point fixe.

%Prenons l'opérateur constant $\phi : \mathcal{F}_{2} \rightarrow
%\mathcal{F}_{2}$ de constante $A : \mathcal{F}_{2} \rightarrow \naturel$ définie
%par:

%\begin{enumerate}
	%\item $A(0, y) = y + 1$
	%\item $A(x + 1, 0) = A(x, 1)$
	%\item $A(x + 1, y + 1) = A(x, A(x + 1, y))$
%\end{enumerate}

%Cet opérateur est constante, donc continu et total. De plus, son point fixe $A$
%est totale car $\gamma^{i}(\emptyset)$ tend vers $\naturel^{2}$ (car $\bigcup_{i
%\in \naturel} \gamma^{i}(\emptyset)$ est le plus petit point fixe).


%\begin{definition}
	%\textbf{La fonction d'Ackermann} $A$ est la fonction
	%de $\naturel^{2}$ dans $\naturel$ définie par
	%\begin{enumerate}
		%\item $A(0, y) = y + 1$
		%\item $A(x + 1, 0) = A(x, 1)$
		%\item $A(x + 1, y + 1) = A(x, A(x + 1, y))$
	%\end{enumerate}
%\end{definition}

%Nous allons montrer que $A$ est de plus récursive, mais n'est pas RP.

\begin{proposition}
	Soit l'opérateur $\gamma : \mathcal{F}_{2} \rightarrow \mathcal{F}_{2}$
	tel que, pour tout $F \in \mathcal{F}_{2}$,
	\begin{enumerate}
		\item $[\gamma(F)] (0, y) = y + 1$
		\item $[\gamma(F)] (x + 1, 0) = F(x, 1)$
		\item $[\gamma(F)] (x + 1, y + 1) = F(x, F(x + 1, y))$
	\end{enumerate}

	Alors, $\gamma$ est continu.
\end{proposition}

\ifdefined\outputproof
\begin{proof}
	Nous devons montrer, pour tout $F \in \mathcal{F}_{2}$

\end{proof}
\fi

\begin{definition}
	Soit $\phi$ un opérateur de $\mathcal{F}_{k}$ dans $\mathcal{F}_{l}$ où $k,
	l$ sont deux entiers strictement positifs.

	On dit que $\phi$ est \textbf{récursif} s'il est continu et si pour toute fonction finie $f \in
	\mathcal{F}_{k}$, et pour tout $(x_{1}, \cdots, x_{k})$, l'application de
	$\mathcal{F}_{l}$ obtenue en évaluant $\phi(f)$ en $(x_{1}, \cdots, x_{k})$ (ie
	$\phi(f)(x_{1}, \cdots, x_{k})$) est récursive.
\end{definition}

Donnons un lemme qui permettra de mieux travailler avec la définition
d'opérateur récursif.

\begin{lemma}
	Soient $k, l \in \naturel^{> 0}$.
	Soit $\GSfunction{\phi}{\mathcal{F}_{k}}{\mathcal{F}_{l}}$ un opérateur.

	Alors, les assertions suivantes sont équivalentes.
	\begin{enumerate}
		\item $\phi$ est récursif.
		\item il existe une fonction totale récursive $H(n)$
	tel que $\phi([n]^{(k)}) = H(n)^{(l)}$.
	\end{enumerate}
\end{lemma}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

On est alors mené au \textit{théorème de récursion de Kleene}:

\begin{theorem} [Théorème de récursion de Kleene]
	\label{theorem:kleene_recursion}
	Soit $k \in \naturel^{> 0}$.
	Soit $\GSfunction{\phi}{\mathcal{F}_{k}}{\mathcal{F}_{k}}$ un opérateur
	récursif.

	Alors le plus petit point fixe $Fix(\phi)$ de $\phi$ est une fonction partielle récursive.
\end{theorem}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

\begin{corollary}
	\label{corollary:ackermann_total_recursive}
	La fonction d'Ackermann $A$ est une fonction totale récursive.
\end{corollary}

\ifdefined\outputproof
\begin{proof}

\end{proof}
\fi

Cependant, nous allons montrer que la fonction d'Ackermann n'est pas RP. Nous
aurons besoin d'une liste de propriétés de $A$.

\begin{proposition}
	\begin{enumerate}
		\item $\forall x, y \in \naturel$, $A(x, y) > y$.
		\item $A$ est strictement croissante en sa deuxième variable.
		\item $\forall x, y \in \naturel$, $A(x, y + 1) \leq A(x + 1, y)$ (la
			fonction grandit plus vite en sa première variable).
		\item $A$ est strictement croissante en sa première variable.
		\item Pour tout $k > 0$ et pour toute fonction
			$\GSfunction{F}{\naturel^{k}}{\naturel}$ RP, il existe $m \in \naturel$
			tel que $F(x_{1}, \cdots, x_{k}) < A(m, max(x_{1}, \cdots, x_{k}))$.
			En d'autre terme, toute fonction RP peut être majorée par $A$, ou
			encore autrement dit, $A$ est plus grande que toute fonction $RP$.
		\item En conclure de $A$ n'est pas RP.
	\end{enumerate}
\end{proposition}

Nous avons donc trouver une fonction totale récursive qui n'est pas RP. Nous
nous étions demandés si le principe de minimalisation permet de construire de
nouvelles fonctions totales. En raison de l'égalité entre les classes
$\muRecursiveFunctionSet$ et $\recursiveFunctionsSet$, et de l'existence de la
fonction d'Ackermann $A$ qui est totale mais pas RP, nous avons que le principe
permet de construire de nouvelles fonctions totales.

